apiVersion: tekton.dev/v1
kind: PipelineRun
metadata:
  annotations:
    build.appstudio.openshift.io/repo: https://github.com/ralphbean/logging-vector?rev={{revision}}
    build.appstudio.redhat.com/commit_sha: '{{revision}}'
    build.appstudio.redhat.com/pull_request_number: '{{pull_request_number}}'
    build.appstudio.redhat.com/target_branch: '{{target_branch}}'
    pipelinesascode.tekton.dev/max-keep-runs: "3"
    pipelinesascode.tekton.dev/on-cel-expression: event == "pull_request" && target_branch == "main"
  creationTimestamp: null
  labels:
    appstudio.openshift.io/application: logging-vector
    appstudio.openshift.io/component: vector
    pipelines.appstudio.openshift.io/type: build
  name: vector-on-pull-request
  namespace: rhn-support-kdudka-tenant
spec:
  params:
    - name: dockerfile
      value: Dockerfile
    - name: git-url
      value: '{{source_url}}'
    - name: image-expires-after
      value: 5d
    - name: output-image
      value: quay.io/redhat-user-workloads/rhn-support-kdudka-tenant/logging-vector/vector:on-pr-{{revision}}
    - name: path-context
      value: .
    - name: revision
      value: '{{revision}}'
  pipelineSpec:
    finally:
      - name: show-sbom
        params:
          - name: IMAGE_URL
            value: $(tasks.build-container.results.IMAGE_URL)
        taskRef:
          params:
            - name: name
              value: show-sbom
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-show-sbom:0.1@sha256:3ea2255c6ad2dd1074de45227deab51b69dba57901f44dbca80fe1c57646b107
            - name: kind
              value: task
          resolver: bundles
      - name: show-summary
        params:
          - name: pipelinerun-name
            value: $(context.pipelineRun.name)
          - name: git-url
            value: $(tasks.clone-repository.results.url)?rev=$(tasks.clone-repository.results.commit)
          - name: image-url
            value: $(params.output-image)
          - name: build-task-status
            value: $(tasks.build-container.status)
        taskRef:
          params:
            - name: name
              value: summary
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-summary:0.2@sha256:abdf426424f1331c27be80ed98a0fbcefb8422767d1724308b9d57b37f977155
            - name: kind
              value: task
          resolver: bundles
        workspaces:
          - name: workspace
            workspace: workspace
    params:
      - description: Source Repository URL
        name: git-url
        type: string
      - default: ""
        description: Revision of the Source Repository
        name: revision
        type: string
      - description: Fully Qualified Output Image
        name: output-image
        type: string
      - default: .
        description: Path to the source code of an application's component from where to build image.
        name: path-context
        type: string
      - default: Dockerfile
        description: Path to the Dockerfile inside the context specified by parameter path-context
        name: dockerfile
        type: string
      - default: "false"
        description: Force rebuild image
        name: rebuild
        type: string
      - default: "false"
        description: Skip checks against built image
        name: skip-checks
        type: string
      - default: "false"
        description: Execute the build with network isolation
        name: hermetic
        type: string
      - default: ""
        description: Build dependencies to be prefetched by Cachi2
        name: prefetch-input
        type: string
      - default: "false"
        description: Java build
        name: java
        type: string
      - default: ""
        description: Image tag expiration time, time values could be something like 1h, 2d, 3w for hours, days, and weeks, respectively.
        name: image-expires-after
      - default: "false"
        description: Build a source image.
        name: build-source-image
        type: string
      - default: ""
        description: Path to a file with build arguments which will be passed to podman during build
        name: build-args-file
        type: string
    results:
      - description: ""
        name: IMAGE_URL
        value: $(tasks.build-container.results.IMAGE_URL)
      - description: ""
        name: IMAGE_DIGEST
        value: $(tasks.build-container.results.IMAGE_DIGEST)
      - description: ""
        name: CHAINS-GIT_URL
        value: $(tasks.clone-repository.results.url)
      - description: ""
        name: CHAINS-GIT_COMMIT
        value: $(tasks.clone-repository.results.commit)
      - description: ""
        name: JAVA_COMMUNITY_DEPENDENCIES
        value: $(tasks.build-container.results.JAVA_COMMUNITY_DEPENDENCIES)
    tasks:
      - name: init
        params:
          - name: image-url
            value: $(params.output-image)
          - name: rebuild
            value: $(params.rebuild)
          - name: skip-checks
            value: $(params.skip-checks)
        taskRef:
          params:
            - name: name
              value: init
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-init:0.2@sha256:596b7c11572bb94eb67d9ffb4375068426e2a8249ff2792ce04ad2a4bc593a63
            - name: kind
              value: task
          resolver: bundles
      - name: clone-repository
        params:
          - name: url
            value: $(params.git-url)
          - name: revision
            value: $(params.revision)
        runAfter:
          - init
        taskRef:
          params:
            - name: name
              value: git-clone
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-git-clone:0.1@sha256:e1f7a275d722bc3147a65fcd772b16b54ccb6ce81c76939bc1052b2438dd2ccf
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(tasks.init.results.build)
            operator: in
            values:
              - "true"
        workspaces:
          - name: output
            workspace: workspace
          - name: basic-auth
            workspace: git-auth
      - name: prefetch-dependencies
        params:
          - name: input
            value: $(params.prefetch-input)
        runAfter:
          - clone-repository
        taskRef:
          params:
            - name: name
              value: prefetch-dependencies
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-prefetch-dependencies:0.1@sha256:66f0dd9f20f4dc1ab9374523d5e8acd721c622edc241153f0e79cf6d8c122d98
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(params.prefetch-input)
            operator: notin
            values:
              - ""
        workspaces:
          - name: source
            workspace: workspace
          - name: git-basic-auth
            workspace: git-auth
      - name: build-container
        params:
          - name: IMAGE
            value: $(params.output-image)
          - name: DOCKERFILE
            value: $(params.dockerfile)
          - name: CONTEXT
            value: $(params.path-context)
          - name: HERMETIC
            value: $(params.hermetic)
          - name: PREFETCH_INPUT
            value: $(params.prefetch-input)
          - name: IMAGE_EXPIRES_AFTER
            value: $(params.image-expires-after)
          - name: COMMIT_SHA
            value: $(tasks.clone-repository.results.commit)
          - name: BUILD_ARGS_FILE
            value: $(params.build-args-file)
        runAfter:
          - prefetch-dependencies
        when:
          - input: $(tasks.init.results.build)
            operator: in
            values:
              - "true"
        workspaces:
          - name: source
            workspace: workspace
        taskSpec:
          description: |-
            Buildah task builds source code into a container image and pushes the image into container registry using buildah tool.
            In addition it generates a SBOM file, injects the SBOM file into final container image and pushes the SBOM file as separate image using cosign tool.
            When [Java dependency rebuild](https://redhat-appstudio.github.io/docs.stonesoup.io/Documentation/main/cli/proc_enabled_java_dependencies.html) is enabled it triggers rebuilds of Java artifacts.
            When prefetch-dependencies task was activated it is using its artifacts to run build in hermetic environment.
          params:
            - description: Reference of the image buildah will produce.
              name: IMAGE
              type: string
            - default: ""
              description: Deprecated. Has no effect. Will be removed in the future.
              name: BUILDER_IMAGE
              type: string
            - default: ./Dockerfile
              description: Path to the Dockerfile to build.
              name: DOCKERFILE
              type: string
            - default: .
              description: Path to the directory to use as context.
              name: CONTEXT
              type: string
            - default: "true"
              description: Verify the TLS on the registry endpoint (for push/pull to a non-TLS registry)
              name: TLSVERIFY
              type: string
            - default: ""
              description: unused, should be removed in next task version
              name: DOCKER_AUTH
              type: string
            - default: "false"
              description: Determines if build will be executed without network access.
              name: HERMETIC
              type: string
            - default: ""
              description: In case it is not empty, the prefetched content should be made available to the build.
              name: PREFETCH_INPUT
              type: string
            - default: ""
              description: Delete image tag after specified time. Empty means to keep the image tag. Time values could be something like 1h, 2d, 3w for hours, days, and weeks, respectively.
              name: IMAGE_EXPIRES_AFTER
              type: string
            - default: ""
              description: The image is built from this commit.
              name: COMMIT_SHA
              type: string
            - default: repos.d
              description: Path in the git repository in which yum repository files are stored
              name: YUM_REPOS_D_SRC
            - default: fetched.repos.d
              description: Path in source workspace where dynamically-fetched repos are present
              name: YUM_REPOS_D_FETCHED
            - default: /etc/yum.repos.d
              description: Target path on the container in which yum repository files should be made available
              name: YUM_REPOS_D_TARGET
            - default: ""
              description: Target stage in Dockerfile to build. If not specified, the Dockerfile is processed entirely to (and including) its last stage.
              name: TARGET_STAGE
              type: string
            - default: etc-pki-entitlement
              description: Name of secret which contains the entitlement certificates
              name: ENTITLEMENT_SECRET
              type: string
            - default: []
              description: Array of --build-arg values ("arg=value" strings)
              name: BUILD_ARGS
              type: array
            - default: ""
              description: Path to a file with build arguments, see https://www.mankier.com/1/buildah-build#--build-arg-file
              name: BUILD_ARGS_FILE
              type: string
          results:
            - description: Digest of the image just built
              name: IMAGE_DIGEST
            - description: Image repository where the built image was pushed
              name: IMAGE_URL
            - description: Digests of the base images used for build
              name: BASE_IMAGES_DIGESTS
            - description: The counting of Java components by publisher in JSON format
              name: SBOM_JAVA_COMPONENTS_COUNT
              type: string
            - description: The Java dependencies that came from community sources such as Maven central.
              name: JAVA_COMMUNITY_DEPENDENCIES
          stepTemplate:
            env:
              - name: BUILDAH_FORMAT
                value: oci
              - name: STORAGE_DRIVER
                value: vfs
              - name: HERMETIC
                value: $(params.HERMETIC)
              - name: CONTEXT
                value: $(params.CONTEXT)
              - name: DOCKERFILE
                value: $(params.DOCKERFILE)
              - name: IMAGE
                value: $(params.IMAGE)
              - name: TLSVERIFY
                value: $(params.TLSVERIFY)
              - name: IMAGE_EXPIRES_AFTER
                value: $(params.IMAGE_EXPIRES_AFTER)
              - name: YUM_REPOS_D_SRC
                value: $(params.YUM_REPOS_D_SRC)
              - name: YUM_REPOS_D_FETCHED
                value: $(params.YUM_REPOS_D_FETCHED)
              - name: YUM_REPOS_D_TARGET
                value: $(params.YUM_REPOS_D_TARGET)
              - name: TARGET_STAGE
                value: $(params.TARGET_STAGE)
              - name: PARAM_BUILDER_IMAGE
                value: $(params.BUILDER_IMAGE)
              - name: ENTITLEMENT_SECRET
                value: $(params.ENTITLEMENT_SECRET)
              - name: BUILD_ARGS_FILE
                value: $(params.BUILD_ARGS_FILE)
          steps:
            - args:
                - $(params.BUILD_ARGS[*])
              computeResources:
                limits:
                  memory: 4Gi
                requests:
                  cpu: 250m
                  memory: 512Mi
              env:
                - name: COMMIT_SHA
                  value: $(params.COMMIT_SHA)
              image: quay.io/redhat-appstudio/buildah:v1.35.4@sha256:3d3575bb7d0df64abcf1f22f06e82101a945d03317db1f3caac12814f796d01c
              name: build
              script: |
                if [ -n "${PARAM_BUILDER_IMAGE}" ]; then
                  echo "WARNING: provided deprecated BUILDER_IMAGE parameter has no effect."
                fi

                SOURCE_CODE_DIR=source
                if [ -e "$SOURCE_CODE_DIR/$CONTEXT/$DOCKERFILE" ]; then
                  dockerfile_path="$(pwd)/$SOURCE_CODE_DIR/$CONTEXT/$DOCKERFILE"
                elif [ -e "$SOURCE_CODE_DIR/$DOCKERFILE" ]; then
                  dockerfile_path="$(pwd)/$SOURCE_CODE_DIR/$DOCKERFILE"
                elif echo "$DOCKERFILE" | grep -q "^https\?://"; then
                  echo "Fetch Dockerfile from $DOCKERFILE"
                  dockerfile_path=$(mktemp --suffix=-Dockerfile)
                  http_code=$(curl -s -L -w "%{http_code}" --output "$dockerfile_path" "$DOCKERFILE")
                  if [ $http_code != 200 ]; then
                    echo "No Dockerfile is fetched. Server responds $http_code"
                    exit 1
                  fi
                  http_code=$(curl -s -L -w "%{http_code}" --output "$dockerfile_path.dockerignore.tmp" "$DOCKERFILE.dockerignore")
                  if [ $http_code = 200 ]; then
                    echo "Fetched .dockerignore from $DOCKERFILE.dockerignore"
                    mv "$dockerfile_path.dockerignore.tmp" $SOURCE_CODE_DIR/$CONTEXT/.dockerignore
                  fi
                else
                  echo "Cannot find Dockerfile $DOCKERFILE"
                  exit 1
                fi
                if [ -n "$JVM_BUILD_WORKSPACE_ARTIFACT_CACHE_PORT_80_TCP_ADDR" ] && grep -q '^\s*RUN \(./\)\?mvn' "$dockerfile_path"; then
                  sed -i -e "s|^\s*RUN \(\(./\)\?mvn\)\(.*\)|RUN echo \"<settings><mirrors><mirror><id>mirror.default</id><url>http://$JVM_BUILD_WORKSPACE_ARTIFACT_CACHE_PORT_80_TCP_ADDR/v1/cache/default/0/</url><mirrorOf>*</mirrorOf></mirror></mirrors></settings>\" > /tmp/settings.yaml; \1 -s /tmp/settings.yaml \3|g" "$dockerfile_path"
                  touch /var/lib/containers/java
                fi

                # install csutils, including csdiff-static
                dnf install -y 'dnf-command(copr)'
                dnf copr enable -y packit/csutils-csdiff-196
                dnf install -y cs{diff{,-static},gcca,wrap}

                # Fixing group permission on /var/lib/containers
                chown root:root /var/lib/containers

                sed -i 's/^\s*short-name-mode\s*=\s*.*/short-name-mode = "disabled"/' /etc/containers/registries.conf

                # Setting new namespace to run buildah - 2^32-2
                echo 'root:1:4294967294' | tee -a /etc/subuid >> /etc/subgid

                BUILDAH_ARGS=()

                BASE_IMAGES=$(grep -i '^\s*FROM' "$dockerfile_path" | sed 's/--platform=\S*//' | awk '{print $2}')
                if [ "${HERMETIC}" == "true" ]; then
                  BUILDAH_ARGS+=("--pull=never")
                  UNSHARE_ARGS="--net"
                  for image in $BASE_IMAGES; do
                    if [ "${image}" != "scratch" ]; then
                      unshare -Ufp --keep-caps -r --map-users 1,1,65536 --map-groups 1,1,65536 -- buildah pull $image
                    fi
                  done
                  echo "Build will be executed with network isolation"
                fi

                if [ -n "${TARGET_STAGE}" ]; then
                  BUILDAH_ARGS+=("--target=${TARGET_STAGE}")
                fi

                if [ -n "${BUILD_ARGS_FILE}" ]; then
                  BUILDAH_ARGS+=("--build-arg-file=$(pwd)/$SOURCE_CODE_DIR/${BUILD_ARGS_FILE}")
                fi

                for build_arg in "$@"; do
                  BUILDAH_ARGS+=("--build-arg=$build_arg")
                done

                if [ -d "$(workspaces.source.path)/cachi2" ]; then
                  cp -r "$(workspaces.source.path)/cachi2" /tmp/
                  chmod -R go+rwX /tmp/cachi2
                  VOLUME_MOUNTS="--volume /tmp/cachi2:/cachi2"
                  sed -i 's|^\s*run |RUN . /cachi2/cachi2.env \&\& \\
                    |i' "$dockerfile_path"
                  echo "Prefetched content will be made available"

                  prefetched_repo_for_my_arch="/tmp/cachi2/output/deps/rpm/$(uname -m)/repos.d/cachi2.repo"
                  if [ -f "$prefetched_repo_for_my_arch" ]; then
                    echo "Adding $prefetched_repo_for_my_arch to $YUM_REPOS_D_FETCHED"
                    mkdir -p "$YUM_REPOS_D_FETCHED"
                    cp --no-clobber "$prefetched_repo_for_my_arch" "$YUM_REPOS_D_FETCHED"
                  fi
                fi

                # if yum repofiles stored in git, copy them to mount point outside the source dir
                if [ -d "${SOURCE_CODE_DIR}/${YUM_REPOS_D_SRC}" ]; then
                  mkdir -p ${YUM_REPOS_D_FETCHED}
                  cp -r ${SOURCE_CODE_DIR}/${YUM_REPOS_D_SRC}/* ${YUM_REPOS_D_FETCHED}
                fi

                # if anything in the repofiles mount point (either fetched or from git), mount it
                if [ -d "${YUM_REPOS_D_FETCHED}" ]; then
                  chmod -R go+rwX ${YUM_REPOS_D_FETCHED}
                  mount_point=$(realpath ${YUM_REPOS_D_FETCHED})
                  VOLUME_MOUNTS="${VOLUME_MOUNTS} --volume ${mount_point}:${YUM_REPOS_D_TARGET}"
                fi

                LABELS=(
                  "--label" "build-date=$(date -u +'%Y-%m-%dT%H:%M:%S')"
                  "--label" "architecture=$(uname -m)"
                  "--label" "vcs-type=git"
                )
                [ -n "$COMMIT_SHA" ] && LABELS+=("--label" "vcs-ref=$COMMIT_SHA")
                [ -n "$IMAGE_EXPIRES_AFTER" ] && LABELS+=("--label" "quay.expires-after=$IMAGE_EXPIRES_AFTER")

                ENTITLEMENT_PATH="/entitlement"
                if [ -d "$ENTITLEMENT_PATH" ]; then
                  cp -r --preserve=mode "$ENTITLEMENT_PATH" /tmp/entitlement
                  VOLUME_MOUNTS="${VOLUME_MOUNTS} --volume /tmp/entitlement:/etc/pki/entitlement"
                  echo "Adding the entitlement to the build"
                fi

                # pre-create files for raw SAST scan results
                cap_dir="$(workspaces.source.path)/gcc-capture"
                mkdir "${cap_dir}"
                touch "${cap_dir}/empty.json"

                # hook GCC Analyzer on the system compiler and capture its output
                # convert GCC's plain-text output to JSON
                # TODO: make GCC produce JSON output for each process separately
                # embed source code context after the build/scan (needed for csdiff/v1 SARIF fingerprints)
                cap_file_raw="/tmp/gcc-capture.txt"
                tee /usr/bin/cmd-wrap.sh << EOF
                #!/bin/bash -x
                env "PATH=/usr/lib64/csgcca:/usr/lib64/cswrap:\$PATH" "CSWRAP_CAP_FILE=${cap_file_raw}" CSWRAP_TIMEOUT=10 CSWRAP_TIMEOUT_FOR=gcc "\$@"
                EC=\$?
                if test -f "${cap_file_raw}"; then
                  cap_file_json="$cap_dir/gcc-\$\$.json"
                  /usr/libexec/csgrep-static --mode=json --event=^warning --embed-context=3 --quiet "${cap_file_raw}" >"\${cap_file_json}"
                  rm -fv "${cap_file_raw}"
                  /usr/libexec/csgrep-static --mode=evtstat "\${cap_file_json}"
                fi
                exit \$EC
                EOF
                chmod 0755 /usr/bin/cmd-wrap.sh
                for i in /usr/bin/cmd-wrap.sh /usr/{bin,lib64}/cs{gcca,wrap} /usr/libexec/csgrep-static "$cap_dir"; do
                  VOLUME_MOUNTS="${VOLUME_MOUNTS} --volume ${i}:${i}"
                done
                cstrans-df-run --in-place "$dockerfile_path" --verbose /usr/bin/cmd-wrap.sh

                unshare -Uf $UNSHARE_ARGS --keep-caps -r --map-users 1,1,65536 --map-groups 1,1,65536 -w ${SOURCE_CODE_DIR}/$CONTEXT -- buildah build \
                  $VOLUME_MOUNTS \
                  "${BUILDAH_ARGS[@]}" \
                  "${LABELS[@]}" \
                  --tls-verify=$TLSVERIFY --no-cache \
                  --ulimit nofile=4096:4096 \
                  -f "$dockerfile_path" -t $IMAGE .

                (
                  set -x

                  # concatenate scan results from all RUN lines (we change working directory to avoid exceeding command line length)
                  (cd "${cap_dir}" && csgrep --mode=json --remove-duplicates *.json) > gcc.json

                  # print key events to CI log
                  csgrep --prune=0 gcc.json

                  # print SAST scanning summary
                  csgrep --mode=evtstat gcc.json

                  # convert the SAST scanning results to SARIF
                  csgrep --mode=sarif gcc.json > gcc.sarif

                  # check how many csdiff/v1 fingerprints were produced
                  grep csdiff/v0 gcc.sarif | wc -l
                  grep csdiff/v1 gcc.sarif | wc -l
                )

                container=$(buildah from --pull-never $IMAGE)
                buildah mount $container | tee /workspace/container_path
                echo $container > /workspace/container_name

                # Save the SBOM produced by Cachi2 so it can be merged into the final SBOM later
                if [ -d "$(workspaces.source.path)/cachi2" ]; then
                  cp /tmp/cachi2/output/bom.json ./sbom-cachi2.json
                fi

                # Expose base image digests
                for image in $BASE_IMAGES; do
                  if [ "${image}" != "scratch" ]; then
                    buildah images --format '{{ .Name }}:{{ .Tag }}@{{ .Digest }}' --filter reference="$image" >> $(results.BASE_IMAGES_DIGESTS.path)
                  fi
                done

                # Needed to generate base images SBOM
                echo "$BASE_IMAGES" > $(workspaces.source.path)/base_images_from_dockerfile
              securityContext:
                capabilities:
                  add:
                    - SETFCAP
              volumeMounts:
                - mountPath: /var/lib/containers
                  name: varlibcontainers
                - mountPath: /entitlement
                  name: etc-pki-entitlement
              workingDir: $(workspaces.source.path)
            - image: quay.io/redhat-appstudio/syft:v1.2.0@sha256:f608cdf9159270124cacfb8e1b2d17fcae05dd869d1a339dd316ede8ad6e5063
              name: sbom-syft-generate
              script: |
                echo "Running syft on the source directory"
                syft dir:$(workspaces.source.path)/source --output cyclonedx-json=$(workspaces.source.path)/sbom-source.json
                find $(cat /workspace/container_path) -xtype l -delete
                echo "Running syft on the image filesystem"
                syft dir:$(cat /workspace/container_path) --output cyclonedx-json=$(workspaces.source.path)/sbom-image.json
              volumeMounts:
                - mountPath: /var/lib/containers
                  name: varlibcontainers
              workingDir: $(workspaces.source.path)/source
            - image: quay.io/redhat-appstudio/hacbs-jvm-build-request-processor:127ee0c223a2b56a9bd20a6f2eaeed3bd6015f77
              name: analyse-dependencies-java-sbom
              script: |
                if [ -f /var/lib/containers/java ]; then
                  /opt/jboss/container/java/run/run-java.sh analyse-dependencies path $(cat /workspace/container_path) -s $(workspaces.source.path)/sbom-image.json --task-run-name $(context.taskRun.name) --publishers $(results.SBOM_JAVA_COMPONENTS_COUNT.path)
                  sed -i 's/^/ /' $(results.SBOM_JAVA_COMPONENTS_COUNT.path) # Workaround for SRVKP-2875
                else
                  touch $(results.JAVA_COMMUNITY_DEPENDENCIES.path)
                fi
              securityContext:
                runAsUser: 0
              volumeMounts:
                - mountPath: /var/lib/containers
                  name: varlibcontainers
            - image: registry.access.redhat.com/ubi9/python-39:1-192@sha256:01c9e53b32acd96f9fe7781727140df6868c91ebc916ed95dc58999fbf4d8ddd
              name: merge-syft-sboms
              script: |
                #!/bin/python3
                import json

                # load SBOMs
                with open("./sbom-image.json") as f:
                  image_sbom = json.load(f)

                with open("./sbom-source.json") as f:
                  source_sbom = json.load(f)

                # fetch unique components from available SBOMs
                def get_identifier(component):
                  return component["name"] + '@' + component.get("version", "")

                image_sbom_components = image_sbom.get("components", [])
                existing_components = [get_identifier(component) for component in image_sbom_components]

                source_sbom_components = source_sbom.get("components", [])
                for component in source_sbom_components:
                  if get_identifier(component) not in existing_components:
                    image_sbom_components.append(component)
                    existing_components.append(get_identifier(component))

                image_sbom_components.sort(key=lambda c: get_identifier(c))

                # write the CycloneDX unified SBOM
                with open("./sbom-cyclonedx.json", "w") as f:
                  json.dump(image_sbom, f, indent=4)
              securityContext:
                runAsUser: 0
              workingDir: $(workspaces.source.path)
            - image: quay.io/redhat-appstudio/cachi2:0.9.0@sha256:c5b62c585438a2396018cc8b410694c73e7e9e6c706f64110dd293d6b06b021d
              name: merge-cachi2-sbom
              script: |
                if [ -d "$(workspaces.source.path)/cachi2" ]; then
                  echo "Merging contents of sbom-cachi2.json into sbom-cyclonedx.json"
                  /src/utils/merge_syft_sbom.py sbom-cachi2.json sbom-cyclonedx.json > sbom-temp.json
                  mv sbom-temp.json sbom-cyclonedx.json
                else
                  echo "Skipping step since no Cachi2 SBOM was produced"
                fi
              securityContext:
                runAsUser: 0
              workingDir: $(workspaces.source.path)
            - image: registry.access.redhat.com/ubi9/python-39:1-192@sha256:01c9e53b32acd96f9fe7781727140df6868c91ebc916ed95dc58999fbf4d8ddd
              name: create-purl-sbom
              script: |
                #!/bin/python3
                import json

                with open("./sbom-cyclonedx.json") as f:
                  cyclonedx_sbom = json.load(f)

                purls = [{"purl": component["purl"]} for component in cyclonedx_sbom.get("components", []) if "purl" in component]
                purl_content = {"image_contents": {"dependencies": purls}}

                with open("sbom-purl.json", "w") as output_file:
                  json.dump(purl_content, output_file, indent=4)
              securityContext:
                runAsUser: 0
              workingDir: $(workspaces.source.path)
            - env:
                - name: BASE_IMAGES_DIGESTS_PATH
                  value: $(results.BASE_IMAGES_DIGESTS.path)
              image: quay.io/redhat-appstudio/base-images-sbom-script@sha256:667669e3def018f9dbb8eaf8868887a40bc07842221e9a98f6787edcff021840
              name: create-base-images-sbom
              script: |
                python3 /app/base_images_sbom_script.py --sbom=sbom-cyclonedx.json --base-images-from-dockerfile=base_images_from_dockerfile --base-images-digests=$BASE_IMAGES_DIGESTS_PATH
              securityContext:
                runAsUser: 0
              workingDir: $(workspaces.source.path)
            - computeResources: {}
              image: quay.io/redhat-appstudio/buildah:v1.35.4@sha256:3d3575bb7d0df64abcf1f22f06e82101a945d03317db1f3caac12814f796d01c
              name: inject-sbom-and-push
              script: |
                if [ -n "${PARAM_BUILDER_IMAGE}" ]; then
                  echo "WARNING: provided deprecated BUILDER_IMAGE parameter has no effect."
                fi

                base_image_name=$(buildah inspect --format '{{ index .ImageAnnotations "org.opencontainers.image.base.name"}}' $IMAGE | cut -f1 -d'@')
                base_image_digest=$(buildah inspect --format '{{ index .ImageAnnotations "org.opencontainers.image.base.digest"}}' $IMAGE)
                container=$(buildah from --pull-never $IMAGE)
                buildah copy $container sbom-cyclonedx.json sbom-purl.json /root/buildinfo/content_manifests/
                buildah config -a org.opencontainers.image.base.name=${base_image_name} -a org.opencontainers.image.base.digest=${base_image_digest} $container
                buildah commit $container $IMAGE

                status=-1
                max_run=5
                sleep_sec=10
                for run in $(seq 1 $max_run); do
                  status=0
                  [ "$run" -gt 1 ] && sleep $sleep_sec
                  echo "Pushing sbom image to registry"
                  buildah push \
                    --tls-verify=$TLSVERIFY \
                    --digestfile $(workspaces.source.path)/image-digest $IMAGE \
                    docker://$IMAGE && break || status=$?
                done
                if [ "$status" -ne 0 ]; then
                    echo "Failed to push sbom image to registry after ${max_run} tries"
                    exit 1
                fi

                cat "$(workspaces.source.path)"/image-digest | tee $(results.IMAGE_DIGEST.path)
                echo -n "$IMAGE" | tee $(results.IMAGE_URL.path)
              securityContext:
                capabilities:
                  add:
                    - SETFCAP
                runAsUser: 0
              volumeMounts:
                - mountPath: /var/lib/containers
                  name: varlibcontainers
              workingDir: $(workspaces.source.path)
            - args:
                - attach
                - sbom
                - --sbom
                - sbom-cyclonedx.json
                - --type
                - cyclonedx
                - $(params.IMAGE)
              image: quay.io/redhat-appstudio/cosign:v2.1.1@sha256:c883d6f8d39148f2cea71bff4622d196d89df3e510f36c140c097b932f0dd5d5
              name: upload-sbom
              workingDir: $(workspaces.source.path)
            - name: upload-gcc-results
              image: quay.io/konflux-ci/oras:latest@sha256:04cbd5efbcf1a38944b050e3adbc3071218643f6aa92e95d5d25b173574bca5e
              workingDir: $(workspaces.source.path)
              script: |
                #!/usr/bin/env bash

                IMAGE_URL=$(cat $(results.IMAGE_URL.path))
                UPLOAD_FILE=gcc.sarif
                MEDIA_TYPE=application/sarif+json

                if [ -z "${IMAGE_URL}" ]; then
                  echo 'No image-url provided. Skipping upload.'
                  exit 0;
                else
                  echo "IMAGE_URL=${IMAGE_URL}"
                fi
            
                if [ ! -f "${UPLOAD_FILE}" ]; then
                  echo "No ${UPLOAD_FILE} exists. Skipping upload."
                  exit 0;
                fi

                echo "Selecting auth"
                select-oci-auth $IMAGE_URL > $HOME/auth.json
                echo "Attaching to ${IMAGE_URL} via the OCI 1.1 Referrers API"
                oras attach --no-tty --registry-config "$HOME/auth.json" --distribution-spec v1.1-referrers-api --artifact-type "${MEDIA_TYPE}" "${IMAGE_URL}" "${UPLOAD_FILE}:${MEDIA_TYPE}"
                echo "Attaching to ${IMAGE_URL} via the OCI 1.1 Referrers Tag"
                oras attach --no-tty --registry-config "$HOME/auth.json" --distribution-spec v1.1-referrers-tag --artifact-type "${MEDIA_TYPE}" "${IMAGE_URL}" "${UPLOAD_FILE}:${MEDIA_TYPE}"
          volumes:
            - emptyDir: {}
              name: varlibcontainers
            - name: etc-pki-entitlement
              secret:
                optional: true
                secretName: $(params.ENTITLEMENT_SECRET)
          workspaces:
            - description: Workspace containing the source code to build.
              name: source
      - name: build-source-image
        params:
          - name: BINARY_IMAGE
            value: $(params.output-image)
          - name: BASE_IMAGES
            value: $(tasks.build-container.results.BASE_IMAGES_DIGESTS)
        runAfter:
          - build-container
        taskRef:
          params:
            - name: name
              value: source-build
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-source-build:0.1@sha256:929bf55a5e364c957a5f907a5516fb8f8893c389ae5985767de7311736eb904a
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(tasks.init.results.build)
            operator: in
            values:
              - "true"
          - input: $(params.build-source-image)
            operator: in
            values:
              - "true"
        workspaces:
          - name: workspace
            workspace: workspace
      - name: deprecated-base-image-check
        params:
          - name: BASE_IMAGES_DIGESTS
            value: $(tasks.build-container.results.BASE_IMAGES_DIGESTS)
          - name: IMAGE_URL
            value: $(tasks.build-container.results.IMAGE_URL)
          - name: IMAGE_DIGEST
            value: $(tasks.build-container.results.IMAGE_DIGEST)
        runAfter:
          - build-container
        taskRef:
          params:
            - name: name
              value: deprecated-image-check
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-deprecated-image-check:0.4@sha256:3f956e0cd9b0a183e4fd95e010aa668a788ef564d3af1f7aecaaf6e2ccc2ce93
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(params.skip-checks)
            operator: in
            values:
              - "false"
      - name: clair-scan
        params:
          - name: image-digest
            value: $(tasks.build-container.results.IMAGE_DIGEST)
          - name: image-url
            value: $(tasks.build-container.results.IMAGE_URL)
        runAfter:
          - build-container
        taskRef:
          params:
            - name: name
              value: clair-scan
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-clair-scan:0.1@sha256:3d9d05162d5807cde4431e80f0f126f4c19994c0c1633629a62ece9a43b966cd
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(params.skip-checks)
            operator: in
            values:
              - "false"
      - name: ecosystem-cert-preflight-checks
        params:
          - name: image-url
            value: $(tasks.build-container.results.IMAGE_URL)
        runAfter:
          - build-container
        taskRef:
          params:
            - name: name
              value: ecosystem-cert-preflight-checks
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-ecosystem-cert-preflight-checks:0.1@sha256:598d9153b1372fc32ccac74020c18a37fa0d66e28099b622f1a4b39905912964
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(params.skip-checks)
            operator: in
            values:
              - "false"
      - name: sast-snyk-check
        runAfter:
          - build-container
        when:
          - input: $(params.skip-checks)
            operator: in
            values:
              - "false"
        workspaces:
          - name: workspace
            workspace: workspace
        params:
        - name: image-digest
          value: $(tasks.build-container.results.IMAGE_DIGEST)
        - name: image-url
          value: $(tasks.build-container.results.IMAGE_URL)
        taskSpec:
          description: Scans source code for security vulnerabilities, including common issues such as SQL injection, cross-site scripting (XSS), and code injection attacks using Snyk Code, a Static Application Security Testing (SAST) tool.
          params:
            - default: snyk-secret
              description: Name of secret which contains Snyk token.
              name: SNYK_SECRET
            - default: --all-projects --exclude=test*,vendor,deps
              description: Append arguments.
              name: ARGS
              type: string
            - description: Image URL.
              name: image-url
              type: string
              # In a future 0.2 version of the task, drop the default to make this required
              default: ""
            - description: Image digest to report findings for.
              name: image-digest
              type: string
              # In a future 0.2 version of the task, drop the default to make this required
              default: ""
          results:
            - description: Tekton task test output.
              name: TEST_OUTPUT
          steps:
            - env:
                - name: SNYK_SECRET
                  value: $(params.SNYK_SECRET)
                - name: ARGS
                  value: $(params.ARGS)
              image: quay.io/redhat-appstudio/konflux-test:v1.4.4@sha256:f3edb13ef6d7d251b1f88c0b564f9d1828eb2f12b986b92c471097bfdb5e8b3d
              name: sast-snyk-check
              script: |
                #!/usr/bin/env bash
                set -euo pipefail
                . /utils.sh
                trap 'handle_error $(results.TEST_OUTPUT.path)' EXIT

                SNYK_TOKEN_PATH="/etc/secrets/snyk_token"

                if [ -f "${SNYK_TOKEN_PATH}" ] && [ -s "${SNYK_TOKEN_PATH}" ]; then
                  # SNYK token is provided
                  SNYK_TOKEN="$(cat ${SNYK_TOKEN_PATH})"
                  export SNYK_TOKEN
                else
                  to_enable_snyk='[here](https://redhat-appstudio.github.io/docs.appstudio.io/Documentation/main/how-to-guides/testing_applications/enable_snyk_check_for_a_product/)'
                  note="Task $(context.task.name) skipped: If you wish to use the Snyk code SAST task, please create a secret name snyk-secret with the key "snyk_token" containing the Snyk token by following the steps given ${to_enable_snyk}"
                  TEST_OUTPUT=$(make_result_json -r SKIPPED -t "$note")
                  echo "${TEST_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
                  exit 0
                fi

                SNYK_EXIT_CODE=0
                SOURCE_CODE_DIR=$(workspaces.workspace.path)/source
                snyk code test $ARGS $SOURCE_CODE_DIR --sarif-file-output=sast_snyk_check_out.json 1>&2>> stdout.txt || SNYK_EXIT_CODE=$?
                test_not_skipped=0
                SKIP_MSG="We found 0 supported files"
                grep -q "$SKIP_MSG" stdout.txt || test_not_skipped=$?

                if [[ "$SNYK_EXIT_CODE" -eq 0 ]] || [[ "$SNYK_EXIT_CODE" -eq 1 ]]; then
                  cat sast_snyk_check_out.json
                  TEST_OUTPUT=
                  parse_test_output $(context.task.name) sarif sast_snyk_check_out.json  || true

                # When the test is skipped, the "SNYK_EXIT_CODE" is 3 and it can also be 3 in some other situation
                elif [[ "$test_not_skipped" -eq 0 ]]; then
                  note="Task $(context.task.name) success: Snyk code test found zero supported files."
                  ERROR_OUTPUT=$(make_result_json -r SUCCESS -t "$note")
                else
                  echo "sast-snyk-check test failed because of the following issues:"
                  cat stdout.txt
                  note="Task $(context.task.name) failed: For details, check Tekton task log."
                  ERROR_OUTPUT=$(make_result_json -r ERROR -t "$note")
                fi
                echo "${TEST_OUTPUT:-${ERROR_OUTPUT}}" | tee $(results.TEST_OUTPUT.path)
              volumeMounts:
                - mountPath: /etc/secrets
                  name: snyk-secret
                  readOnly: true
              workingDir: $(workspaces.workspace.path)/hacbs/$(context.task.name)
            - name: upload
              image: quay.io/konflux-ci/oras:latest@sha256:1619b84cea3777387f643d7a1ecde98dd10904439f31607e66530cd2299c7b91
              workingDir: $(workspaces.workspace.path)/hacbs/$(context.task.name)
              env:
                - name: IMAGE_URL
                  value: $(params.image-url)
                - name: IMAGE_DIGEST
                  value: $(params.image-digest)
              script: |
                #!/usr/bin/env bash
            
                UPLOAD_FILE=sast_snyk_check_out.json
                MEDIA_TYPE=application/sarif+json

                if [ -z "${IMAGE_URL}" ] || [ -z "${IMAGE_DIGEST}"  ]; then
                  echo 'No image-url or image-digest param provided. Skipping upload.'
                  exit 0;
                fi
            
                if [ ! -f "${UPLOAD_FILE}" ]; then
                  echo "No ${UPLOAD_FILE} exists. Skipping upload."
                  exit 0;
                fi
            
                echo "Selecting auth"
                select-oci-auth $IMAGE_URL > $HOME/auth.json
                echo "Attaching to ${IMAGE_URL} via the OCI 1.1 Referrers API"
                oras attach --no-tty --registry-config "$HOME/auth.json" --distribution-spec v1.1-referrers-api --artifact-type "${MEDIA_TYPE}" "${IMAGE_URL}" "${UPLOAD_FILE}:${MEDIA_TYPE}"
                echo "Attaching to ${IMAGE_URL} via the OCI 1.1 Referrers Tag"
                oras attach --no-tty --registry-config "$HOME/auth.json" --distribution-spec v1.1-referrers-tag --artifact-type "${MEDIA_TYPE}" "${IMAGE_URL}" "${UPLOAD_FILE}:${MEDIA_TYPE}"
          volumes:
            - name: snyk-secret
              secret:
                optional: true
                secretName: $(params.SNYK_SECRET)
          workspaces:
            - name: workspace
      - name: clamav-scan
        params:
          - name: image-digest
            value: $(tasks.build-container.results.IMAGE_DIGEST)
          - name: image-url
            value: $(tasks.build-container.results.IMAGE_URL)
        runAfter:
          - build-container
        taskRef:
          params:
            - name: name
              value: clamav-scan
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-clamav-scan:0.1@sha256:559d281b58584386a6faaf0e6641c814f9d877432d1a13bd03076745fffffaf1
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(params.skip-checks)
            operator: in
            values:
              - "false"
      - name: sbom-json-check
        params:
          - name: IMAGE_URL
            value: $(tasks.build-container.results.IMAGE_URL)
          - name: IMAGE_DIGEST
            value: $(tasks.build-container.results.IMAGE_DIGEST)
        runAfter:
          - build-container
        taskRef:
          params:
            - name: name
              value: sbom-json-check
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-sbom-json-check:0.1@sha256:d34362be8843715b1bcdaf55fcbf1be315094e0dc840562c5cec22716a37a1fe
            - name: kind
              value: task
          resolver: bundles
        when:
          - input: $(params.skip-checks)
            operator: in
            values:
              - "false"
      - name: apply-tags
        params:
          - name: IMAGE
            value: $(tasks.build-container.results.IMAGE_URL)
        runAfter:
          - build-container
        taskRef:
          params:
            - name: name
              value: apply-tags
            - name: bundle
              value: quay.io/redhat-appstudio-tekton-catalog/task-apply-tags:0.1@sha256:66bb1c0294595ed9e26bbb6a76499e43ca23b9665fcf6c71006c0c2647f0b29d
            - name: kind
              value: task
          resolver: bundles
    workspaces:
      - name: workspace
      - name: git-auth
        optional: true
  taskRunTemplate: {}
  workspaces:
    - name: workspace
      volumeClaimTemplate:
        metadata:
          creationTimestamp: null
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 3Gi
        status: {}
    - name: git-auth
      secret:
        secretName: '{{ git_auth_secret }}'
status: {}
